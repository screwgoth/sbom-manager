import axios from 'axios';
import { db, vulnerabilities, componentVulnerabilities, components } from '../db';
import { eq } from 'drizzle-orm';

// NVD API configuration
const NVD_API_BASE = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
const NVD_API_KEY = process.env.NVD_API_KEY || '';
const NVD_RATE_LIMIT_MS = NVD_API_KEY ? 600 : 6000; // 0.6s with key, 6s without

// OSV API configuration
const OSV_API_BASE = 'https://api.osv.dev/v1';

// Cache for vulnerability data (in-memory, could be moved to Redis)
const vulnerabilityCache = new Map<string, { data: any; timestamp: number }>();
const CACHE_TTL_MS = 24 * 60 * 60 * 1000; // 24 hours

interface NVDResponse {
  vulnerabilities: Array<{
    cve: {
      id: string;
      descriptions: Array<{ lang: string; value: string }>;
      metrics?: {
        cvssMetricV31?: Array<{
          cvssData: {
            baseScore: number;
            baseSeverity: string;
          };
        }>;
        cvssMetricV2?: Array<{
          cvssData: {
            baseScore: number;
          };
          baseSeverity: string;
        }>;
      };
      references?: Array<{
        url: string;
        source: string;
      }>;
      published?: string;
      lastModified?: string;
      configurations?: Array<{
        nodes: Array<{
          cpeMatch: Array<{
            vulnerable: boolean;
            criteria: string;
            versionStartIncluding?: string;
            versionStartExcluding?: string;
            versionEndIncluding?: string;
            versionEndExcluding?: string;
          }>;
        }>;
      }>;
    };
  }>;
}

interface OSVVulnerability {
  id: string;
  summary: string;
  details: string;
  severity?: Array<{
    type: string;
    score: string;
  }>;
  affected?: Array<{
    package: {
      ecosystem: string;
      name: string;
    };
    ranges?: Array<{
      type: string;
      events: Array<{
        introduced?: string;
        fixed?: string;
        last_affected?: string;
      }>;
    }>;
    versions?: string[];
  }>;
  references?: Array<{
    type: string;
    url: string;
  }>;
  published?: string;
  modified?: string;
}

/**
 * Fetch vulnerability data from NVD API
 */
async function fetchFromNVD(packageName: string, ecosystem: string): Promise<any[]> {
  const cacheKey = `nvd:${ecosystem}:${packageName}`;
  const cached = vulnerabilityCache.get(cacheKey);
  
  if (cached && Date.now() - cached.timestamp < CACHE_TTL_MS) {
    console.log(`[NVD] Cache hit for ${packageName}`);
    return cached.data;
  }

  try {
    // Search by keyword (package name)
    const params: any = {
      keywordSearch: packageName,
      resultsPerPage: 50,
    };

    const headers: any = {
      'User-Agent': 'SBOM-Manager/1.0',
    };

    if (NVD_API_KEY) {
      headers['apiKey'] = NVD_API_KEY;
    }

    console.log(`[NVD] Fetching vulnerabilities for ${packageName}...`);
    const response = await axios.get<NVDResponse>(NVD_API_BASE, {
      params,
      headers,
      timeout: 30000,
    });

    const vulnData = response.data.vulnerabilities || [];
    vulnerabilityCache.set(cacheKey, { data: vulnData, timestamp: Date.now() });

    // Respect rate limiting
    await new Promise(resolve => setTimeout(resolve, NVD_RATE_LIMIT_MS));

    return vulnData;
  } catch (error: any) {
    console.error(`[NVD] Error fetching vulnerabilities for ${packageName}:`, error.message);
    return [];
  }
}

/**
 * Fetch vulnerability data from OSV API
 */
async function fetchFromOSV(packageName: string, ecosystem: string): Promise<OSVVulnerability[]> {
  const cacheKey = `osv:${ecosystem}:${packageName}`;
  const cached = vulnerabilityCache.get(cacheKey);
  
  if (cached && Date.now() - cached.timestamp < CACHE_TTL_MS) {
    console.log(`[OSV] Cache hit for ${packageName}`);
    return cached.data;
  }

  try {
    // Map ecosystem to OSV format
    const osvEcosystem = mapEcosystemToOSV(ecosystem);
    
    console.log(`[OSV] Fetching vulnerabilities for ${packageName} (${osvEcosystem})...`);
    const response = await axios.post<{ vulns: OSVVulnerability[] }>(
      `${OSV_API_BASE}/query`,
      {
        package: {
          name: packageName,
          ecosystem: osvEcosystem,
        },
      },
      {
        timeout: 30000,
      }
    );

    const vulnData = response.data.vulns || [];
    vulnerabilityCache.set(cacheKey, { data: vulnData, timestamp: Date.now() });

    return vulnData;
  } catch (error: any) {
    console.error(`[OSV] Error fetching vulnerabilities for ${packageName}:`, error.message);
    return [];
  }
}

/**
 * Map internal ecosystem names to OSV ecosystem names
 */
function mapEcosystemToOSV(ecosystem: string): string {
  const mapping: Record<string, string> = {
    npm: 'npm',
    python: 'PyPI',
    java: 'Maven',
    go: 'Go',
    rust: 'crates.io',
  };
  return mapping[ecosystem] || ecosystem;
}

/**
 * Parse CVSS score and determine severity
 */
function parseSeverity(score: number | null): 'critical' | 'high' | 'medium' | 'low' | 'none' {
  if (!score) return 'none';
  if (score >= 9.0) return 'critical';
  if (score >= 7.0) return 'high';
  if (score >= 4.0) return 'medium';
  if (score >= 0.1) return 'low';
  return 'none';
}

/**
 * Check if a version matches an affected range
 */
function isVersionAffected(
  version: string,
  range: {
    versionStartIncluding?: string;
    versionStartExcluding?: string;
    versionEndIncluding?: string;
    versionEndExcluding?: string;
  }
): boolean {
  const v = parseVersion(version);
  
  if (range.versionStartIncluding) {
    const start = parseVersion(range.versionStartIncluding);
    if (compareVersions(v, start) < 0) return false;
  }
  
  if (range.versionStartExcluding) {
    const start = parseVersion(range.versionStartExcluding);
    if (compareVersions(v, start) <= 0) return false;
  }
  
  if (range.versionEndIncluding) {
    const end = parseVersion(range.versionEndIncluding);
    if (compareVersions(v, end) > 0) return false;
  }
  
  if (range.versionEndExcluding) {
    const end = parseVersion(range.versionEndExcluding);
    if (compareVersions(v, end) >= 0) return false;
  }
  
  return true;
}

/**
 * Parse version string into comparable array
 */
function parseVersion(version: string): number[] {
  // Remove leading 'v' if present
  const cleaned = version.replace(/^v/, '');
  // Split by dots and convert to numbers
  return cleaned.split(/[.-]/).map(part => {
    const num = parseInt(part, 10);
    return isNaN(num) ? 0 : num;
  });
}

/**
 * Compare two version arrays
 */
function compareVersions(v1: number[], v2: number[]): number {
  const maxLen = Math.max(v1.length, v2.length);
  for (let i = 0; i < maxLen; i++) {
    const a = v1[i] || 0;
    const b = v2[i] || 0;
    if (a < b) return -1;
    if (a > b) return 1;
  }
  return 0;
}

/**
 * Process NVD vulnerability and store in database
 */
async function processNVDVulnerability(nvdVuln: any, componentId: string, componentVersion: string): Promise<void> {
  const cve = nvdVuln.cve;
  const cveId = cve.id;
  
  // Extract CVSS score and severity
  let cvssScore: number | null = null;
  let severity: 'critical' | 'high' | 'medium' | 'low' | 'none' = 'none';
  
  if (cve.metrics?.cvssMetricV31?.[0]) {
    cvssScore = cve.metrics.cvssMetricV31[0].cvssData.baseScore;
    severity = parseSeverity(cvssScore);
  } else if (cve.metrics?.cvssMetricV2?.[0]) {
    cvssScore = cve.metrics.cvssMetricV2[0].cvssData.baseScore;
    severity = parseSeverity(cvssScore);
  }
  
  // Extract description
  const description = cve.descriptions?.find((d: any) => d.lang === 'en')?.value || 'No description available';
  
  // Check if version is affected
  let isAffected = false;
  let affectedVersions = '';
  let fixedVersion = null;
  
  if (cve.configurations) {
    for (const config of cve.configurations) {
      for (const node of config.nodes || []) {
        for (const match of node.cpeMatch || []) {
          if (match.vulnerable) {
            const range = {
              versionStartIncluding: match.versionStartIncluding,
              versionStartExcluding: match.versionStartExcluding,
              versionEndIncluding: match.versionEndIncluding,
              versionEndExcluding: match.versionEndExcluding,
            };
            
            if (isVersionAffected(componentVersion, range)) {
              isAffected = true;
              affectedVersions = JSON.stringify(range);
              if (match.versionEndExcluding) {
                fixedVersion = match.versionEndExcluding;
              }
              break;
            }
          }
        }
        if (isAffected) break;
      }
      if (isAffected) break;
    }
  }
  
  if (!isAffected) return; // Skip if version not affected
  
  // Extract references
  const references = cve.references?.map((ref: any) => ({
    url: ref.url,
    source: ref.source,
  })) || [];
  
  // Check if vulnerability already exists
  const existing = await db.select()
    .from(vulnerabilities)
    .where(eq(vulnerabilities.cveId, cveId))
    .limit(1);
  
  let vulnerabilityId: string;
  
  if (existing.length > 0) {
    // Update existing
    vulnerabilityId = existing[0].id;
    await db.update(vulnerabilities)
      .set({
        severity,
        cvssScore: cvssScore?.toString(),
        description,
        affectedVersions,
        fixedVersion,
        references: JSON.stringify(references),
        lastUpdated: new Date(),
        publishedDate: cve.published ? new Date(cve.published) : undefined,
      })
      .where(eq(vulnerabilities.id, vulnerabilityId));
  } else {
    // Insert new
    const inserted = await db.insert(vulnerabilities).values({
      cveId,
      severity,
      cvssScore: cvssScore?.toString(),
      description,
      affectedVersions,
      fixedVersion,
      references: JSON.stringify(references),
      publishedDate: cve.published ? new Date(cve.published) : undefined,
    }).returning();
    vulnerabilityId = inserted[0].id;
  }
  
  // Link to component
  await linkVulnerabilityToComponent(componentId, vulnerabilityId);
}

/**
 * Process OSV vulnerability and store in database
 */
async function processOSVVulnerability(osvVuln: OSVVulnerability, componentId: string, componentVersion: string): Promise<void> {
  const cveId = osvVuln.id;
  
  // Extract severity
  let cvssScore: number | null = null;
  let severity: 'critical' | 'high' | 'medium' | 'low' | 'none' = 'none';
  
  if (osvVuln.severity) {
    const cvssV3 = osvVuln.severity.find(s => s.type === 'CVSS_V3');
    if (cvssV3) {
      const match = cvssV3.score.match(/(\d+\.\d+)/);
      if (match) {
        cvssScore = parseFloat(match[1]);
        severity = parseSeverity(cvssScore);
      }
    }
  }
  
  const description = osvVuln.details || osvVuln.summary || 'No description available';
  
  // Check if version is affected
  let isAffected = false;
  let affectedVersions = '';
  let fixedVersion = null;
  
  if (osvVuln.affected) {
    for (const affected of osvVuln.affected) {
      if (affected.versions?.includes(componentVersion)) {
        isAffected = true;
      } else if (affected.ranges) {
        for (const range of affected.ranges) {
          for (const event of range.events) {
            if (event.introduced && !event.fixed) {
              isAffected = true;
            }
            if (event.fixed) {
              fixedVersion = event.fixed;
            }
          }
        }
      }
    }
  }
  
  if (!isAffected) return; // Skip if version not affected
  
  // Extract references
  const references = osvVuln.references?.map(ref => ({
    type: ref.type,
    url: ref.url,
  })) || [];
  
  // Check if vulnerability already exists
  const existing = await db.select()
    .from(vulnerabilities)
    .where(eq(vulnerabilities.cveId, cveId))
    .limit(1);
  
  let vulnerabilityId: string;
  
  if (existing.length > 0) {
    vulnerabilityId = existing[0].id;
  } else {
    // Insert new
    const inserted = await db.insert(vulnerabilities).values({
      cveId,
      severity,
      cvssScore: cvssScore?.toString(),
      description,
      affectedVersions,
      fixedVersion,
      references: JSON.stringify(references),
      publishedDate: osvVuln.published ? new Date(osvVuln.published) : undefined,
    }).returning();
    vulnerabilityId = inserted[0].id;
  }
  
  // Link to component
  await linkVulnerabilityToComponent(componentId, vulnerabilityId);
}

/**
 * Link vulnerability to component (avoid duplicates)
 */
async function linkVulnerabilityToComponent(componentId: string, vulnerabilityId: string): Promise<void> {
  // Check if link already exists
  const existingLink = await db.select()
    .from(componentVulnerabilities)
    .where(eq(componentVulnerabilities.componentId, componentId))
    .where(eq(componentVulnerabilities.vulnerabilityId, vulnerabilityId))
    .limit(1);
  
  if (existingLink.length === 0) {
    await db.insert(componentVulnerabilities).values({
      componentId,
      vulnerabilityId,
      status: 'open',
    });
  }
}

/**
 * Scan SBOM for vulnerabilities
 */
export async function scanSBOMForVulnerabilities(sbomId: string): Promise<{
  scanned: number;
  vulnerabilitiesFound: number;
}> {
  console.log(`[Vuln Scanner] Starting scan for SBOM ${sbomId}`);
  
  // Get all components for this SBOM
  const sbomComponents = await db.select()
    .from(components)
    .where(eq(components.sbomId, sbomId));
  
  let vulnerabilitiesFound = 0;
  
  for (const component of sbomComponents) {
    try {
      const ecosystem = (component.metadata as any)?.ecosystem || 'unknown';
      const packageName = component.name;
      const version = component.version;
      
      console.log(`[Vuln Scanner] Scanning ${packageName}@${version} (${ecosystem})`);
      
      // Try OSV first (faster, better maintained)
      const osvVulns = await fetchFromOSV(packageName, ecosystem);
      
      for (const vuln of osvVulns) {
        await processOSVVulnerability(vuln, component.id, version);
        vulnerabilitiesFound++;
      }
      
      // Fallback to NVD if OSV returns no results
      if (osvVulns.length === 0) {
        const nvdVulns = await fetchFromNVD(packageName, ecosystem);
        
        for (const vuln of nvdVulns) {
          await processNVDVulnerability(vuln, component.id, version);
          vulnerabilitiesFound++;
        }
      }
    } catch (error: any) {
      console.error(`[Vuln Scanner] Error scanning ${component.name}:`, error.message);
    }
  }
  
  console.log(`[Vuln Scanner] Scan complete. Found ${vulnerabilitiesFound} vulnerabilities in ${sbomComponents.length} components`);
  
  return {
    scanned: sbomComponents.length,
    vulnerabilitiesFound,
  };
}

/**
 * Get vulnerability summary for SBOM
 */
export async function getVulnerabilitySummaryForSBOM(sbomId: string): Promise<{
  critical: number;
  high: number;
  medium: number;
  low: number;
  none: number;
  total: number;
}> {
  const sbomComponents = await db.select()
    .from(components)
    .where(eq(components.sbomId, sbomId));
  
  const componentIds = sbomComponents.map(c => c.id);
  
  const summary = {
    critical: 0,
    high: 0,
    medium: 0,
    low: 0,
    none: 0,
    total: 0,
  };
  
  for (const componentId of componentIds) {
    const vulns = await db.select({
      severity: vulnerabilities.severity,
    })
    .from(componentVulnerabilities)
    .innerJoin(vulnerabilities, eq(componentVulnerabilities.vulnerabilityId, vulnerabilities.id))
    .where(eq(componentVulnerabilities.componentId, componentId));
    
    for (const vuln of vulns) {
      summary[vuln.severity as keyof typeof summary]++;
      summary.total++;
    }
  }
  
  return summary;
}

/**
 * Get vulnerabilities for a component
 */
export async function getVulnerabilitiesForComponent(componentId: string) {
  return await db.select({
    vulnerability: vulnerabilities,
    status: componentVulnerabilities.status,
  })
  .from(componentVulnerabilities)
  .innerJoin(vulnerabilities, eq(componentVulnerabilities.vulnerabilityId, vulnerabilities.id))
  .where(eq(componentVulnerabilities.componentId, componentId));
}
